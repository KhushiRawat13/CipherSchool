Naive Approach:
---------------
Code: A simple for loop iterates through all elements.
Time Complexity: ùëÇ(ùëõ)
O(n) because the loop runs once for each of the n elements.
Asymptotic Notations:
Big-O: : O(n), upper bound for runtime.
Omega : (Œ©): Œ©(n), lower bound as it will always loop through n elements.
Theta : Œò(n), tight bound as runtime is exactly proportional to n.

Recursive Approach:
--------------------
Code: Recursively sums the first element with the result of a smaller subproblem.
Time Complexity: O(n), as the function is called n+1 times (one for each element and one for the base case).
Space Complexity: O(n) due to the recursion stack.
Asymptotic Notations:
Big-O: O(n), upper bound as there are n recursive calls.

Space Complexity:O(n) due to the recursion stack.zz

Omega : 
Œ©(n), lower bound due to n recursive calls.
Theta Œò(n), as the runtime is proportional to n.


Using Built-in Functions:
------------------------
Code: Uses std::accumulate which is optimized for summing a range of numbers.
Time Complexity: O(n), as std::accumulate internally iterates through n elements.
Asymptotic Notations:
Big-O O(n), upper bound for runtime.
Omega Œ©(n), lower bound for n elements.
Theta Œò(n), as the sum operation is proportional to n.